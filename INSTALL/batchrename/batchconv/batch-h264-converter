#!/usr/bin/php5
<?php
require_once('config.php');
require_once('lib-mediainfo.php');

$dirPath = $argv[1];

$fileTypes = array('mkv','avi','mp4','divx','m4v','mov','mpg','wmv');

class scanDir {
    static private $directories, $files, $ext_filter, $recursive;

// ----------------------------------------------------------------------------------------------
    // scan(dirpath::string|array, extensions::string|array, recursive::true|false)
    static public function scan(){
        // Initialize defaults
        self::$recursive = false;
        self::$directories = array();
        self::$files = array();
        self::$ext_filter = false;

        // Check we have minimum parameters
        if(!$args = func_get_args()){
            die("Must provide a path string or array of path strings");
        }
        if(gettype($args[0]) != "string" && gettype($args[0]) != "array"){
            die("Must provide a path string or array of path strings");
        }

        // Check if recursive scan | default action: no sub-directories
        if(isset($args[2]) && $args[2] == true){self::$recursive = true;}

        // Was a filter on file extensions included? | default action: return all file types
        if(isset($args[1])){
            if(gettype($args[1]) == "array"){self::$ext_filter = array_map('strtolower', $args[1]);}
            else
            if(gettype($args[1]) == "string"){self::$ext_filter[] = strtolower($args[1]);}
        }

        // Grab path(s)
        self::verifyPaths($args[0]);
        return self::$files;
    }

    static private function verifyPaths($paths){
        $path_errors = array();
        if(gettype($paths) == "string"){$paths = array($paths);}

        foreach($paths as $path){
            if(is_dir($path)){
                self::$directories[] = $path;
                $dirContents = self::find_contents($path);
            } else {
                $path_errors[] = $path;
            }
        }

        if($path_errors){echo "The following directories do not exists<br />";die(var_dump($path_errors));}
    }

    // This is how we scan directories
    static private function find_contents($dir){
        $result = array();
        $root = scandir($dir);
        foreach($root as $value){
            if($value === '.' || $value === '..') {continue;}
            if(is_file($dir.DIRECTORY_SEPARATOR.$value)){
                if(!self::$ext_filter || in_array(strtolower(pathinfo($dir.DIRECTORY_SEPARATOR.$value, PATHINFO_EXTENSION)), self::$ext_filter)){
                    self::$files[] = $result[] = $dir.DIRECTORY_SEPARATOR.$value;
                }
                continue;
            }
            if(self::$recursive){
                foreach(self::find_contents($dir.DIRECTORY_SEPARATOR.$value) as $value) {
                    self::$files[] = $result[] = $value;
                }
            }
        }
        // Return required for recursive search
        return $result;
    }
}

function logLine($msg){
	echo $msg."\n";
	syslog(LOG_INFO,'H.264 Converter: '.$msg);
};

function notify($title,$msg){
		global $config;
		
		if($config['pushBulletEmail']){
			$postFields = array(
				"email" => $config['pushBulletEmail'],
				"type" => "note",
				"title" => $title,
				"body" => $msg,
				"sender_name" => "H.264 Converter"
			);

			$curl = curl_init('https://api.pushbullet.com/v2/pushes');
			curl_setopt($curl, CURLOPT_RETURNTRANSFER, true);
			curl_setopt($curl, CURLOPT_POST, true);
			curl_setopt($curl, CURLOPT_HTTPHEADER, ['Authorization: Bearer '.$config['pushBulletApiKey']]);
			curl_setopt($curl, CURLOPT_POSTFIELDS, $postFields);
			curl_setopt($curl, CURLOPT_SSL_VERIFYPEER, false);

			return curl_exec($curl);
		};
};

function find_all_files($dir)
{
    $root = scandir($dir);
    foreach($root as $value)
    {
        if($value === '.' || $value === '..') {continue;}
        if(is_file("$dir/$value")) 
		{
		$result[]="$dir/$value";
		continue;
		}
        foreach(find_all_files("$dir/$value") as $value)
        {
            $result[]=$value;
        }
    }
    return $result;
} 

//$dirListing = find_all_files($dirPath);
$dirListing = scanDir::scan($dirPath, $fileTypes, true);
print_r($dirListing);

foreach($dirListing as $d){
	$doConvert = false;
	$matchStr = strtolower(substr($d,strlen($d)-3,3));
	if(in_array($matchStr,$fileTypes)){
		$dPath = ($d);
                //print_r($dPath);
		logLine('=== '.$dPath.' ===');
		$mediaInfo = new mediaInfo($dPath);
		$mediaInfo = json_decode(json_encode($mediaInfo),true);
		//print_r($mediaInfo);
		
		//Decision points as to whether we will convert
			
			//Check video format
			if($mediaInfo['arrGeneral']['Format'] <> "MPEG-4"){
				logLine('ISSUE: Container is not MPEG4 ('.$mediaInfo['arrGeneral']['Format'].')');
				$doConvert = true;
			};
			
			//Check video codec
			if($mediaInfo['arrVideo']['Format'] <> "AVC"){
				logLine('ISSUE: Video codec is not AVC/H.264 ('.$mediaInfo['arrVideo']['Format'].')');
				$doConvert = true;
			};
			
			//Check audio codec
			$audio = $mediaInfo['arrAudio'];
			reset($audio);
			$firstAudioKey = key($audio);
			if($mediaInfo['arrAudio'][$firstAudioKey]['Format'] <> "AAC"){
				logLine('ISSUE: Audio codec is not AAC ('.$mediaInfo['arrAudio'][$firstAudioKey]['Format'].')');
				$doConvert = true;
			};
			
			//Need to check what it looks like with multiple tracks / languages
			if(count($mediaInfo['arrAudio']) > 1){
				logLine('NOPE: More than one audio track');
				$doConvert = false;
				print_r($mediaInfo);
				exit;
			};
			
			//Deal with packaging subtitles
			if(count($mediaInfo['arrText'])){
				//TODO:  Remove non-english subtitles
				//Currently subtitles will be included as MOV_TEXT so you can turn them on and off
				//Probably will never get written as there's little benifit to removing others
			};
	
	
		//Do it
		if($doConvert){
			$sourceFile = $mediaInfo['arrGeneral']['Complete name'];
			$src = pathinfo($sourceFile);
			$hash = md5($sourceFile);
			
			$workingFile = $config['dir']['scratch'].$hash.'.mp4';
			$destFile = $src['dirname'] . '/' . $src['filename'] . '.mp4';
			
			logLine('Source: '.$sourceFile);
			logLine('Scratch: '.$workingFile);
			logLine('Dest: '.$destFile);
			
			$timeStart = time();
			
			$ffCmd  = 'ffmpeg -i "'.$sourceFile.'" -c:v libx264 -crf '.$config['videoQuality'];
			
			//H.264 quality setting - suggested by @jmckee on the Plex forums
			if($config['h264Level']){
				$ffCmd .= ' -level '.$config['h264Level'].' ';
			};
			
			//Add totally customised arguments to the FFMPEG command
			if($config['customFfmpegArgs']){
				$ffCmd .= ' '.$config['customFfmpegArgs'].' ';
			};
			
			$ffCmd .= ' -preset '.$config['speed'].' -c:a aac -q:a '.$config['audioQuality'].' -c:s mov_text -movflags +faststart -strict -2 "'.$workingFile.'"';
			logLine('Running command: '.$ffCmd);
			if(!$config['test']){exec($ffCmd);};
			
/*			
			if($config['keepInJunkyard']){
				logLine('Moving the original source to the junkyard...');
				$junkFile = $config['dir']['junkyard'] . $src['basename'];
				$junkCmd = 'mv "'.$sourceFile. '" "'.$junkFile.'"';
				logLine($junkCmd);
				if(!$config['test']){exec($junkCmd);};
			}else{
				logLine('Deleting original...');
				$junkFile = $config['dir']['junkyard'] . $src['basename'];
				$rmCmd = 'rm "'.$sourceFile. '"';
				logLine($rmCmd);
				if(!$config['test']){exec($rmCmd);};
			};
*/			
			logLine('Moving converted file into place of original...');
			//$moveCmd = 'mv "'.$workingFile. '" "'.$destFile.'"';
                        $moveCmd = 'rsync --remove-source-files "'.$workingFile. '" "'.$destFile.'"';
			logLine($moveCmd);
			if(!$config['test']){exec($moveCmd);};
#			logLine('Remove Temp Files...');
#			$rmCmd = 'rm "'.$workingFile.'"';
#			logLine($rmCmd);
#			if(!$config['test']){exec($rmCmd);};			

			$timeTaken = time() - $timeStart;
			
			notify('Conversion finished',$src['filename'].' ['.round($timeTaken/60).' minutes]');
			
		}else{
			logLine('Not converting this file');
		};
		
	};
	
};



?>